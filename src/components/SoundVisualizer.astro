---
// SoundVisualizer.astro - Interactive sound waveform visualizer for switches
interface Props {
  switchName?: string;
  audioUrl?: string;
  waveformData?: number[];
}

const { 
  switchName = 'Switch Audio',
  audioUrl = '', 
  waveformData = [] 
} = Astro.props;

// Generate sample waveform data if none provided
const sampleWaveform = waveformData.length > 0 ? waveformData : Array.from({length: 100}, (_, i) => {
  const base = Math.sin(i * 0.1) * 0.3;
  const noise = (Math.random() - 0.5) * 0.4;
  const envelope = Math.exp(-i * 0.02) * 0.7;
  return Math.max(0.05, Math.min(1, base + noise + envelope));
});
---

<div class="sound-visualizer w-full" id="sound-visualizer">
  <!-- Header -->
  <div class="flex items-center justify-between mb-6">
    <div class="space-y-2">
      <h3 class="text-2xl font-bold text-gradient">Sound Visualizer</h3>
      <p class="text-muted-foreground">Analyze the acoustic signature of {switchName}</p>
    </div>
    
    <!-- Controls -->
    <div class="flex items-center space-x-3">
      <button 
        id="play-button" 
        class="btn-glow px-4 py-2 text-sm"
        disabled={!audioUrl}
      >
        <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
          <path d="M8 5v10l8-5-8-5z"/>
        </svg>
        Play
      </button>
      <button 
        id="record-button" 
        class="px-4 py-2 text-sm bg-red-500/20 text-red-300 border border-red-500/30 rounded-lg hover:bg-red-500/30 transition-colors duration-200"
      >
        <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
          <circle cx="10" cy="10" r="3"/>
        </svg>
        Record
      </button>
    </div>
  </div>

  <div class="switch-card p-6">
    <!-- Waveform Display -->
    <div class="waveform-container mb-6">
      <canvas 
        id="waveform-canvas" 
        class="w-full h-32 bg-background rounded-lg border border-border"
        width="800" 
        height="128"
      ></canvas>
    </div>

    <!-- Audio Controls -->
    <div class="flex items-center justify-between mb-4">
      <div class="flex items-center space-x-4">
        <span class="text-sm text-muted-foreground">Volume</span>
        <input 
          type="range" 
          id="volume-control" 
          class="w-24 accent-primary"
          min="0" 
          max="100" 
          value="70"
        >
      </div>
      
      <div class="flex items-center space-x-4">
        <span class="text-sm text-muted-foreground">Speed</span>
        <select id="playback-speed" class="px-3 py-1 rounded-md bg-background border border-border text-foreground text-sm">
          <option value="0.5">0.5x</option>
          <option value="0.75">0.75x</option>
          <option value="1" selected>1x</option>
          <option value="1.25">1.25x</option>
          <option value="1.5">1.5x</option>
          <option value="2">2x</option>
        </select>
      </div>
    </div>

    <!-- Frequency Analysis -->
    <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
      <div class="space-y-2">
        <h4 class="font-semibold text-foreground">Frequency Analysis</h4>
        <canvas 
          id="frequency-canvas" 
          class="w-full h-24 bg-background rounded border border-border"
          width="200" 
          height="96"
        ></canvas>
      </div>
      
      <div class="space-y-2">
        <h4 class="font-semibold text-foreground">Volume Envelope</h4>
        <canvas 
          id="envelope-canvas" 
          class="w-full h-24 bg-background rounded border border-border"
          width="200" 
          height="96"
        ></canvas>
      </div>
      
      <div class="space-y-2">
        <h4 class="font-semibold text-foreground">Acoustic Properties</h4>
        <div class="space-y-2 text-sm">
          <div class="flex justify-between">
            <span class="text-muted-foreground">Peak Frequency</span>
            <span class="text-primary font-medium" id="peak-freq">-- Hz</span>
          </div>
          <div class="flex justify-between">
            <span class="text-muted-foreground">Duration</span>
            <span class="text-primary font-medium" id="duration">-- ms</span>
          </div>
          <div class="flex justify-between">
            <span class="text-muted-foreground">Thock Rating</span>
            <span class="text-accent font-medium" id="thock-rating">--</span>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Audio element for playback -->
<audio id="audio-player" preload="metadata" {audioUrl && `src="${audioUrl}"`}></audio>

<script>
  class SoundVisualizer {
    constructor() {
      this.canvas = document.getElementById('waveform-canvas');
      this.ctx = this.canvas?.getContext('2d');
      this.freqCanvas = document.getElementById('frequency-canvas');
      this.freqCtx = this.freqCanvas?.getContext('2d');
      this.envCanvas = document.getElementById('envelope-canvas');
      this.envCtx = this.envCanvas?.getContext('2d');
      
      this.playButton = document.getElementById('play-button');
      this.recordButton = document.getElementById('record-button');
      this.volumeControl = document.getElementById('volume-control');
      this.speedControl = document.getElementById('playback-speed');
      this.audioPlayer = document.getElementById('audio-player');
      
      this.isPlaying = false;
      this.isRecording = false;
      this.animationId = null;
      this.mediaRecorder = null;
      this.recordedChunks = [];
      
      // Sample waveform data (embedded from Astro)
      this.waveformData = {JSON.stringify(sampleWaveform)};
      
      this.init();
    }
    
    init() {
      this.setupEventListeners();
      this.drawWaveform();
      this.drawFrequencyAnalysis();
      this.drawEnvelope();
      this.updateAcousticProperties();
    }
    
    setupEventListeners() {
      this.playButton?.addEventListener('click', () => this.togglePlayback());
      this.recordButton?.addEventListener('click', () => this.toggleRecording());
      
      this.volumeControl?.addEventListener('input', (e) => {
        if (this.audioPlayer) {
          this.audioPlayer.volume = e.target.value / 100;
        }
      });
      
      this.speedControl?.addEventListener('change', (e) => {
        if (this.audioPlayer) {
          this.audioPlayer.playbackRate = parseFloat(e.target.value);
        }
      });
      
      this.audioPlayer?.addEventListener('ended', () => {
        this.isPlaying = false;
        this.updatePlayButton();
        this.stopVisualization();
      });
      
      this.audioPlayer?.addEventListener('loadedmetadata', () => {
        this.updateDuration();
      });
    }
    
    async togglePlayback() {
      if (!this.audioPlayer?.src) {
        this.simulatePlayback();
        return;
      }
      
      if (this.isPlaying) {
        this.audioPlayer.pause();
        this.isPlaying = false;
        this.stopVisualization();
      } else {
        await this.audioPlayer.play();
        this.isPlaying = true;
        this.startVisualization();
      }
      this.updatePlayButton();
    }
    
    simulatePlayback() {
      if (this.isPlaying) {
        this.isPlaying = false;
        this.stopVisualization();
      } else {
        this.isPlaying = true;
        this.startVisualization();
        // Auto-stop after 3 seconds
        setTimeout(() => {
          this.isPlaying = false;
          this.updatePlayButton();
          this.stopVisualization();
        }, 3000);
      }
      this.updatePlayButton();
    }
    
    async toggleRecording() {
      if (this.isRecording) {
        this.stopRecording();
      } else {
        await this.startRecording();
      }
    }
    
    async startRecording() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        this.mediaRecorder = new MediaRecorder(stream);
        this.recordedChunks = [];
        
        this.mediaRecorder.ondataavailable = (event) => {
          if (event.data.size > 0) {
            this.recordedChunks.push(event.data);
          }
        };
        
        this.mediaRecorder.onstop = () => {
          const blob = new Blob(this.recordedChunks, { type: 'audio/webm' });
          const url = URL.createObjectURL(blob);
          this.audioPlayer.src = url;
          this.analyzeRecordedAudio();
        };
        
        this.mediaRecorder.start();
        this.isRecording = true;
        this.updateRecordButton();
        
        // Auto-stop after 5 seconds
        setTimeout(() => {
          if (this.isRecording) {
            this.stopRecording();
          }
        }, 5000);
        
      } catch (error) {
        console.error('Error starting recording:', error);
        alert('Unable to access microphone. Please check permissions.');
      }
    }
    
    stopRecording() {
      if (this.mediaRecorder && this.isRecording) {
        this.mediaRecorder.stop();
        this.mediaRecorder.stream.getTracks().forEach(track => track.stop());
        this.isRecording = false;
        this.updateRecordButton();
      }
    }
    
    startVisualization() {
      let progress = 0;
      const animate = () => {
        if (!this.isPlaying) return;
        
        progress += 0.02;
        if (progress > 1) progress = 0;
        
        this.drawWaveformProgress(progress);
        this.animationId = requestAnimationFrame(animate);
      };
      animate();
    }
    
    stopVisualization() {
      if (this.animationId) {
        cancelAnimationFrame(this.animationId);
        this.animationId = null;
      }
      this.drawWaveform(); // Reset to static view
    }
    
    drawWaveform() {
      if (!this.ctx || !this.canvas) return;
      
      const { width, height } = this.canvas;
      this.ctx.clearRect(0, 0, width, height);
      
      // Grid lines
      this.ctx.strokeStyle = 'rgb(71 85 105 / 0.3)';
      this.ctx.lineWidth = 1;
      for (let i = 0; i < 5; i++) {
        const y = (height / 4) * i;
        this.ctx.beginPath();
        this.ctx.moveTo(0, y);
        this.ctx.lineTo(width, y);
        this.ctx.stroke();
      }
      
      // Waveform
      const gradient = this.ctx.createLinearGradient(0, 0, 0, height);
      gradient.addColorStop(0, 'rgb(59 130 246 / 0.8)');
      gradient.addColorStop(0.5, 'rgb(139 92 246 / 0.6)');
      gradient.addColorStop(1, 'rgb(59 130 246 / 0.4)');
      
      this.ctx.fillStyle = gradient;
      this.ctx.strokeStyle = 'rgb(59 130 246)';
      this.ctx.lineWidth = 2;
      
      this.ctx.beginPath();
      this.ctx.moveTo(0, height / 2);
      
      this.waveformData.forEach((value, index) => {
        const x = (index / this.waveformData.length) * width;
        const y = height / 2 - (value * height / 2 * 0.8);
        if (index === 0) {
          this.ctx.moveTo(x, y);
        } else {
          this.ctx.lineTo(x, y);
        }
      });
      
      // Create filled area
      this.ctx.lineTo(width, height / 2);
      this.ctx.lineTo(0, height / 2);
      this.ctx.closePath();
      this.ctx.fill();
      
      // Draw outline
      this.ctx.beginPath();
      this.waveformData.forEach((value, index) => {
        const x = (index / this.waveformData.length) * width;
        const y = height / 2 - (value * height / 2 * 0.8);
        if (index === 0) {
          this.ctx.moveTo(x, y);
        } else {
          this.ctx.lineTo(x, y);
        }
      });
      this.ctx.stroke();
    }
    
    drawWaveformProgress(progress) {
      if (!this.ctx || !this.canvas) return;
      
      const { width, height } = this.canvas;
      this.ctx.clearRect(0, 0, width, height);
      
      // Draw base waveform
      this.drawWaveform();
      
      // Draw progress indicator
      const progressX = progress * width;
      this.ctx.strokeStyle = 'rgb(34 197 94)';
      this.ctx.lineWidth = 3;
      this.ctx.beginPath();
      this.ctx.moveTo(progressX, 0);
      this.ctx.lineTo(progressX, height);
      this.ctx.stroke();
      
      // Progress glow effect
      this.ctx.shadowColor = 'rgb(34 197 94)';
      this.ctx.shadowBlur = 10;
      this.ctx.stroke();
      this.ctx.shadowBlur = 0;
    }
    
    drawFrequencyAnalysis() {
      if (!this.freqCtx || !this.freqCanvas) return;
      
      const { width, height } = this.freqCanvas;
      this.freqCtx.clearRect(0, 0, width, height);
      
      // Generate sample frequency data
      const freqData = Array.from({length: 20}, (_, i) => {
        const freq = 50 + i * 100; // 50Hz to 2050Hz
        const intensity = Math.exp(-Math.abs(freq - 800) / 300) * Math.random() * 0.8 + 0.1;
        return intensity;
      });
      
      const gradient = this.freqCtx.createLinearGradient(0, height, 0, 0);
      gradient.addColorStop(0, 'rgb(139 92 246 / 0.8)');
      gradient.addColorStop(1, 'rgb(139 92 246 / 0.3)');
      
      this.freqCtx.fillStyle = gradient;
      
      freqData.forEach((intensity, index) => {
        const barWidth = width / freqData.length;
        const barHeight = intensity * height * 0.8;
        const x = index * barWidth;
        const y = height - barHeight;
        
        this.freqCtx.fillRect(x, y, barWidth - 1, barHeight);
      });
    }
    
    drawEnvelope() {
      if (!this.envCtx || !this.envCanvas) return;
      
      const { width, height } = this.envCanvas;
      this.envCtx.clearRect(0, 0, width, height);
      
      // ADSR envelope visualization
      const gradient = this.envCtx.createLinearGradient(0, 0, 0, height);
      gradient.addColorStop(0, 'rgb(34 197 94 / 0.8)');
      gradient.addColorStop(1, 'rgb(34 197 94 / 0.3)');
      
      this.envCtx.fillStyle = gradient;
      this.envCtx.strokeStyle = 'rgb(34 197 94)';
      this.envCtx.lineWidth = 2;
      
      this.envCtx.beginPath();
      // Attack
      this.envCtx.moveTo(0, height);
      this.envCtx.lineTo(width * 0.1, height * 0.1);
      // Decay
      this.envCtx.lineTo(width * 0.3, height * 0.3);
      // Sustain
      this.envCtx.lineTo(width * 0.7, height * 0.3);
      // Release
      this.envCtx.lineTo(width, height);
      this.envCtx.closePath();
      this.envCtx.fill();
      this.envCtx.stroke();
    }
    
    updateAcousticProperties() {
      // Calculate and display acoustic properties
      const peakFreq = Math.round(400 + Math.random() * 800); // Sample data
      const duration = Math.round(50 + Math.random() * 150);
      const thockRating = (Math.random() * 4 + 6).toFixed(1);
      
      document.getElementById('peak-freq').textContent = `${peakFreq} Hz`;
      document.getElementById('duration').textContent = `${duration} ms`;
      document.getElementById('thock-rating').textContent = thockRating;
    }
    
    updatePlayButton() {
      if (this.playButton) {
        this.playButton.innerHTML = this.isPlaying ? 
          '<svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20"><path d="M5 4h3v12H5V4zm7 0h3v12h-3V4z"/></svg> Pause' :
          '<svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20"><path d="M8 5v10l8-5-8-5z"/></svg> Play';
      }
    }
    
    updateRecordButton() {
      if (this.recordButton) {
        this.recordButton.innerHTML = this.isRecording ?
          '<svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20"><rect x="6" y="6" width="8" height="8"/></svg> Stop' :
          '<svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20"><circle cx="10" cy="10" r="3"/></svg> Record';
        
        this.recordButton.className = this.isRecording ?
          'px-4 py-2 text-sm bg-gray-500/20 text-gray-300 border border-gray-500/30 rounded-lg hover:bg-gray-500/30 transition-colors duration-200' :
          'px-4 py-2 text-sm bg-red-500/20 text-red-300 border border-red-500/30 rounded-lg hover:bg-red-500/30 transition-colors duration-200';
      }
    }
    
    updateDuration() {
      if (this.audioPlayer && this.audioPlayer.duration) {
        const duration = Math.round(this.audioPlayer.duration * 1000);
        document.getElementById('duration').textContent = `${duration} ms`;
      }
    }
    
    analyzeRecordedAudio() {
      // Regenerate waveform and properties for recorded audio
      this.waveformData = Array.from({length: 100}, () => Math.random() * 0.8 + 0.1);
      this.drawWaveform();
      this.drawFrequencyAnalysis();
      this.updateAcousticProperties();
    }
  }
  
  // Initialize when DOM is loaded
  document.addEventListener('DOMContentLoaded', () => {
    new SoundVisualizer();
  });
</script>

<style>
  .waveform-container {
    position: relative;
  }
  
  #waveform-canvas,
  #frequency-canvas,
  #envelope-canvas {
    cursor: pointer;
    transition: all 0.2s ease;
  }
  
  #waveform-canvas:hover {
    box-shadow: 0 4px 12px rgb(59 130 246 / 0.3);
  }
  
  /* Custom range slider */
  input[type="range"] {
    -webkit-appearance: none;
    appearance: none;
    height: 4px;
    background: rgb(71 85 105);
    border-radius: 2px;
    outline: none;
  }
  
  input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 16px;
    height: 16px;
    background: rgb(59 130 246);
    border-radius: 50%;
    cursor: pointer;
    border: 2px solid white;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
  }
  
  input[type="range"]::-moz-range-thumb {
    width: 16px;
    height: 16px;
    background: rgb(59 130 246);
    border-radius: 50%;
    cursor: pointer;
    border: 2px solid white;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
  }
  
  /* Responsive adjustments */
  @media (max-width: 768px) {
    .sound-visualizer {
      font-size: 14px;
    }
    
    #waveform-canvas {
      height: 80px;
    }
    
    #frequency-canvas,
    #envelope-canvas {
      height: 60px;
    }
  }
</style>